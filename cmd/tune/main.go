package main

import (
	"encoding/csv"
	"flag"
	"fmt"
	"io"
	"math"
	"math/rand"
	"os"
	"slices"
	"strconv"

	"github.com/shaardie/clemens/pkg/evaluation"
	"github.com/shaardie/clemens/pkg/position"
	"github.com/shaardie/clemens/pkg/types"
)

// Constant K derived from find_k
const K = 0.97116934075534

var inputFilename string

func init() {
	evaluation.Cache = false
	flag.StringVar(&inputFilename, "input", "", "filename of the input file generated by the pgn-to-fen.py script")
}

type eval struct {
	poss []*position.Position
	rs   []float64
}

func (e eval) evaluate(weights evaluation.Weights) float64 {
	evaluation.SetFromWeights(weights)
	var result float64
	for i := 0; i < len(e.poss); i++ {
		var score int16
		for range 10 {
			score = evaluation.Evaluation(e.poss[i])
		}

		if e.poss[i].SideToMove == types.BLACK {
			score *= -1
		}
		result += math.Pow(e.rs[i]-1/(1+math.Pow(10, -K*float64(score)/400)), 2)
	}
	return result
}

func localSearch(initialWeights evaluation.Weights, stepSize int16, poss []*position.Position, rs []float64) (float64, evaluation.Weights) {
	e := eval{
		poss: poss,
		rs:   rs,
	}
	currentWeights := initialWeights
	currentValue := e.evaluate(currentWeights)
	var newValue float64
	var newWeights evaluation.Weights
	orderIndex := make([]int, len(initialWeights))
	for i := range len(initialWeights) {
		orderIndex[i] = i
	}
	rand.Shuffle(len(orderIndex), func(i, j int) { orderIndex[i], orderIndex[j] = orderIndex[j], orderIndex[i] })
	changedRecently := make([]bool, len(initialWeights))

	iter := 0
	for {
		fmt.Printf("iteration='%v', value='%v'\n", iter, currentValue)
		if iter%30 == 0 {
			evaluation.PrintWeights(currentWeights)
		}

		// Shuffle the indices, but the ones not changed recently are last.
		rand.Shuffle(len(orderIndex), func(i, j int) { orderIndex[i], orderIndex[j] = orderIndex[j], orderIndex[i] })
		slices.SortStableFunc(orderIndex, func(idx1, idx2 int) int {
			if changedRecently[idx1] {
				if changedRecently[idx2] {
					return 0
				}
				return 1
			}
			if changedRecently[idx2] {
				return -1
			}
			return 0
		})

		newWeights = currentWeights
		for _, i := range orderIndex {
			newWeights[i] += stepSize
			newValue = e.evaluate(newWeights)
			if newValue < currentValue {
				changedRecently[i] = true
				break
			}
			newWeights[i] -= 2 * stepSize
			newValue = e.evaluate(newWeights)
			if newValue < currentValue {
				changedRecently[i] = true
				break
			}
			newWeights[i] += stepSize
			changedRecently[i] = false
		}

		if !changed(changedRecently) {
			break
		}
		currentValue = newValue
		currentWeights = newWeights
		iter++

	}
	return currentValue, currentWeights
}

func changed(changedRecently []bool) bool {
	for _, v := range changedRecently {
		if v {
			return true
		}
	}
	return false
}

func read(r io.Reader) ([]*position.Position, []float64, error) {
	csvReader := csv.NewReader(r)
	records, err := csvReader.ReadAll()
	if err != nil {
		return nil, nil, err
	}
	rs := make([]float64, len(records))
	poss := make([]*position.Position, len(records))
	for i := range records {
		result := records[i][1]
		r, err := strconv.ParseFloat(result, 64)
		if err != nil {
			return nil, nil, fmt.Errorf("failed to parse result '%v' with index %v, %w", result, i, err)
		}
		rs[i] = r

		fen := records[i][0]
		poss[i], err = position.NewFromFen(fen)
		if err != nil {
			return nil, nil, fmt.Errorf("failed to parse position '%v' with index %v, %w", fen, i, err)
		}
	}
	return poss, rs, nil
}

func mainWithError() error {
	flag.Parse()
	if inputFilename == "" {
		fmt.Println("input filename missing")
		os.Exit(1)
	}
	inputFile, err := os.Open(inputFilename)
	if err != nil {
		return fmt.Errorf("failed to open inputFile %v, %w", inputFilename, err)
	}
	defer inputFile.Close()

	poss, rs, err := read(inputFile)
	if err != nil {
		return fmt.Errorf("failed to read positions and results from reader, %w", err)
	}
	fmt.Println(localSearch(evaluation.GetWeights(), 5, poss, rs))
	evaluation.PrintWeights(evaluation.GetWeights())

	return nil
}

func main() {
	err := mainWithError()
	if err != nil {
		fmt.Println(err)
		os.Exit(1)
	}
}
